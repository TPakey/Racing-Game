import React, { useState } from 'react';
import { Folder, FileCode, FileText, ChevronRight, ChevronDown, Copy, Check, Menu, X } from 'lucide-react';

// --- DATA STRUCTURES ---

const FILE_CONTENT = {
  // --- ROOT ---
  '.gitignore': `/[Ll]ibrary/
/[Tt]emp/
/[Oo]bj/
/[Bb]uild/
/[Bb]uilds/
/[Ll]ogs/
/[Uu]ser[Ss]ettings/

# MemoryCaptures can get excessive
/[Mm]emoryCaptures/

# Asset meta data should only be ignored when the corresponding asset is also ignored
!/[Aa]ssets/**/*.meta

# Autogenerated Jetbrains Rider plugin
/[Aa]ssets/Plugins/Editor/JetBrains*

# Visual Studio cache directory
.vs/
.gradle/
ExportedObj/
.consulo/
*.csproj
*.unityproj
*.sln
*.suo
*.tmp
*.user
*.userprefs
*.pidb
*.booproj
*.svd
*.pdb
*.opendb
*.VC.db

# Unity3D generated meta files
*.pidb.meta
*.pdb.meta
*.mdb.meta

# Builds (Local)
Build/

# WebGL Docs folder (Keep this for GitHub Pages!)
# /docs/`,

  'README.md': `# Drifty Roads

A low-poly arcade racing game built in Unity 2022 LTS.

## Project Structure
- **Assets/DriftyRoads/**: Contains all custom scripts, scenes, and logic for this game.
- **Assets/PolygonStreetRacer/**: (Ignored or assumed present) Place your Synty Polygon assets here.

## How to Setup in Unity
1. Open Unity Hub and Add this project folder.
2. Ensure you are using **Unity 2022.3 LTS** or higher.
3. If you have the *Polygon Street Racer* pack, import it into \`Assets/PolygonStreetRacer\`.
4. Open \`Assets/DriftyRoads/Scenes/MainMenu.unity\` to start.

## WebGL Build & Deployment (GitHub Pages)
This project is configured to be deployed via GitHub Pages.

1. In Unity, go to **File > Build Settings**.
2. Switch Platform to **WebGL**.
3. Click **Player Settings...** > **Resolution and Presentation**.
   - Set "Compression Format" to **Disabled** (safest for GitHub Pages) or **Gzip**.
   - If using Gzip, ensure you add a \`.nojekyll\` file to the root of the repo later.
4. Back in Build Settings, click **Build**.
5. Select the **\`docs\`** folder in the root of the project (create it if it doesn't exist).
   - *Note: GitHub Pages looks for \`index.html\` in the root or \`/docs\`.*
6. Once built, commit and push the \`docs/\` folder to GitHub.
7. On GitHub, go to **Settings > Pages**.
8. Set Source to **Deploy from a branch** -> **main** -> **/docs**.`,

  // --- CORE ---
  'Constants.cs': `namespace DriftyRoads.Core
{
    public static class Constants
    {
        public const string SCENE_MAIN_MENU = "MainMenu";
        public const string SCENE_RACE_01 = "Race_Track01";
        
        public const string TAG_PLAYER = "Player";
        public const string TAG_CHECKPOINT = "Checkpoint";
    }
}`,

  'GameState.cs': `namespace DriftyRoads.Core
{
    public enum GameState
    {
        NotStarted, // Loading logic
        Countdown,  // 3, 2, 1...
        Racing,     // Gameplay active
        Finished,   // Race over
        Paused      // Logic paused
    }
}`,

  // --- PLAYER ---
  'CarController.cs': `using UnityEngine;
using DriftyRoads.Core;

namespace DriftyRoads.Player
{
    [RequireComponent(typeof(Rigidbody))]
    public class CarController : MonoBehaviour
    {
        [Header("Car Settings")]
        [SerializeField] private float maxSpeed = 20f;
        [SerializeField] private float acceleration = 30f;
        [SerializeField] private float steeringSpeed = 5f;
        [SerializeField] private float driftFactor = 0.95f; // Lower = more slippery

        [Header("Visuals")]
        [SerializeField] private Transform carModel; // Assign the visual mesh here
        [SerializeField] private Transform[] frontWheels;
        [SerializeField] private Transform[] rearWheels;

        private Rigidbody _rb;
        private float _inputMove;
        private float _inputTurn;
        private bool _canControl = false;

        private void Awake()
        {
            _rb = GetComponent<Rigidbody>();
            _rb.centerOfMass = Vector3.down * 0.5f; // Lower COG to prevent flipping
        }

        public void SetControlState(bool canControl)
        {
            _canControl = canControl;
        }

        private void Update()
        {
            if (_canControl)
            {
                GetInput();
            }
            else
            {
                _inputMove = 0f;
                _inputTurn = 0f;
            }
            
            UpdateVisuals();
        }

        private void FixedUpdate()
        {
            Move();
            Turn();
            ApplyGravity();
        }

        private void GetInput()
        {
            _inputMove = Input.GetAxis("Vertical");
            _inputTurn = Input.GetAxis("Horizontal");
        }

        private void Move()
        {
            // Acceleration
            float speed = _rb.velocity.magnitude;
            
            if (_inputMove > 0 && speed < maxSpeed)
            {
                _rb.AddForce(transform.forward * (acceleration * _inputMove), ForceMode.Acceleration);
            }
            else if (_inputMove < 0)
            {
                // Braking / Reversing
                _rb.AddForce(transform.forward * (acceleration * _inputMove), ForceMode.Acceleration);
            }

            // Drift / Grip Logic
            // Kill orthogonal velocity to simulate grip, but leave some for drift
            Vector3 localVelocity = transform.InverseTransformDirection(_rb.velocity);
            localVelocity.x *= driftFactor; 
            _rb.velocity = transform.TransformDirection(localVelocity);
        }

        private void Turn()
        {
            if (_rb.velocity.magnitude > 1f) // Only turn if moving
            {
                // Reverse steering when going backward feels more natural in arcade games
                float direction = _inputMove >= 0 ? 1 : -1;
                float turn = _inputTurn * steeringSpeed * direction * Time.fixedDeltaTime;
                
                Quaternion turnRotation = Quaternion.Euler(0f, turn * 50f, 0f);
                _rb.MoveRotation(_rb.rotation * turnRotation);
            }
        }
        
        private void ApplyGravity()
        {
            // Extra gravity to keep car grounded on slopes
            _rb.AddForce(Vector3.down * 10f, ForceMode.Acceleration);
        }

        private void UpdateVisuals()
        {
            if (carModel == null) return;

            // Simple body roll based on turn
            float roll = -_inputTurn * 5f;
            // Simple pitch based on acceleration
            float pitch = -_inputMove * 2f;

            // Smoothly rotate the body mesh only (not the physics parent)
            carModel.localRotation = Quaternion.Lerp(
                carModel.localRotation, 
                Quaternion.Euler(pitch, 0, roll), 
                Time.deltaTime * 5f
            );

            // Wheel rotation (Visual only)
            if (frontWheels != null)
            {
                foreach (var wheel in frontWheels)
                {
                    // Steering angle
                    Vector3 currentEuler = wheel.localEulerAngles;
                    float steeringAngle = _inputTurn * 30f;
                    wheel.localRotation = Quaternion.Euler(currentEuler.x, steeringAngle, currentEuler.z);
                }
            }
        }
        
        public float GetSpeedKmh()
        {
            // Approximate conversion
            return _rb.velocity.magnitude * 3.6f;
        }
    }
}`,

  'CameraFollow.cs': `using UnityEngine;

namespace DriftyRoads.Player
{
    public class CameraFollow : MonoBehaviour
    {
        [SerializeField] private Transform target;
        [SerializeField] private Vector3 offset = new Vector3(0, 5, -10);
        [SerializeField] private float followSpeed = 10f;
        [SerializeField] private float rotationSpeed = 5f;

        private void FixedUpdate()
        {
            if (target == null) return;

            HandlePosition();
            HandleRotation();
        }

        private void HandlePosition()
        {
            // Transform the offset based on target's rotation to always be behind/above relative to car
            Vector3 targetPosition = target.TransformPoint(offset);
            // Smoothly move
            transform.position = Vector3.Lerp(transform.position, targetPosition, followSpeed * Time.deltaTime);
        }

        private void HandleRotation()
        {
            Vector3 direction = target.position - transform.position;
            Quaternion rotation = Quaternion.LookRotation(direction, Vector3.up);
            transform.rotation = Quaternion.Lerp(transform.rotation, rotation, rotationSpeed * Time.deltaTime);
        }
    }
}`,

  // --- AI ---
  'WaypointCircuit.cs': `using System.Collections.Generic;
using UnityEngine;

namespace DriftyRoads.AI
{
    public class WaypointCircuit : MonoBehaviour
    {
        [SerializeField] private List<Transform> waypoints = new List<Transform>();
        [SerializeField] private Color debugColor = Color.yellow;

        public Transform GetWaypoint(int index)
        {
            if (waypoints.Count == 0) return null;
            return waypoints[index % waypoints.Count];
        }

        public int WaypointCount => waypoints.Count;

        private void OnDrawGizmos()
        {
            if (waypoints.Count < 2) return;

            Gizmos.color = debugColor;
            for (int i = 0; i < waypoints.Count; i++)
            {
                Transform current = waypoints[i];
                Transform next = waypoints[(i + 1) % waypoints.Count];

                if (current != null && next != null)
                {
                    Gizmos.DrawLine(current.position, next.position);
                    Gizmos.DrawSphere(current.position, 1f);
                }
            }
        }
    }
}`,

  'AICarController.cs': `using UnityEngine;
using DriftyRoads.Player;

namespace DriftyRoads.AI
{
    [RequireComponent(typeof(CarController))]
    public class AICarController : MonoBehaviour
    {
        [SerializeField] private WaypointCircuit circuit;
        [SerializeField] private float waypointThreshold = 5f;
        
        private CarController _carController;
        private int _currentWaypointIndex = 0;
        private bool _isActive = false;

        private void Awake()
        {
            _carController = GetComponent<CarController>();
        }

        public void SetActive(bool isActive)
        {
            _isActive = isActive;
            _carController.SetControlState(isActive);
        }

        private void Update()
        {
            if (!_isActive || circuit == null) return;

            Drive();
        }

        private void Drive()
        {
            Transform target = circuit.GetWaypoint(_currentWaypointIndex);
            
            // 1. Steering
            Vector3 relativeVector = transform.InverseTransformPoint(target.position);
            float newSteer = (relativeVector.x / relativeVector.magnitude);
            
            // Fake input simulation
            float forwardInput = 1f; // Always floor it
            
            // Slow down for sharp turns
            if (Mathf.Abs(newSteer) > 0.5f) forwardInput = 0.5f;

            var rb = GetComponent<Rigidbody>();
            
            // Turn
            Quaternion turnRotation = Quaternion.Euler(0f, newSteer * 5f, 0f);
            rb.MoveRotation(rb.rotation * turnRotation);
            
            // Gas
            if (rb.velocity.magnitude < 15f) // AI Speed Limit
            {
                rb.AddForce(transform.forward * (30f * forwardInput), ForceMode.Acceleration);
            }
            
            // Check waypoint distance
            if (Vector3.Distance(transform.position, target.position) < waypointThreshold)
            {
                _currentWaypointIndex++;
            }
        }
    }
}`,

  // --- RACE ---
  'Checkpoint.cs': `using UnityEngine;

namespace DriftyRoads.Race
{
    [RequireComponent(typeof(Collider))]
    public class Checkpoint : MonoBehaviour
    {
        [Tooltip("0 is Start/Finish line. 1, 2, 3... are triggers around the track.")]
        public int index;

        private void Awake()
        {
            GetComponent<Collider>().isTrigger = true;
        }
    }
}`,

  'LapTracker.cs': `using UnityEngine;
using DriftyRoads.Core;
using System;

namespace DriftyRoads.Race
{
    public class LapTracker : MonoBehaviour
    {
        public event Action<int> OnLapCompleted;
        public event Action<int> OnCheckpointPassed;

        private int _lastCheckpointIndex = -1; // -1 means we haven't crossed start line properly yet
        private int _currentLap = 0;
        private int _totalCheckpoints;
        private RaceManager _raceManager;

        public int CurrentLap => _currentLap;

        public void Initialize(RaceManager manager, int totalCheckpointsInScene)
        {
            _raceManager = manager;
            _totalCheckpoints = totalCheckpointsInScene;
            _currentLap = 0; // Lap 0 until we cross start line
            _lastCheckpointIndex = -1; 
        }

        private void OnTriggerEnter(Collider other)
        {
            if (other.CompareTag(Constants.TAG_CHECKPOINT))
            {
                Checkpoint cp = other.GetComponent<Checkpoint>();
                if (cp != null)
                {
                    HandleCheckpoint(cp.index);
                }
            }
        }

        private void HandleCheckpoint(int index)
        {
            // Logic: Must hit checkpoints in order: 0 -> 1 -> 2 -> 0...
            
            // Special Case: Start of race
            if (_currentLap == 0 && index == 0)
            {
                _currentLap = 1;
                _lastCheckpointIndex = 0;
                Debug.Log($"Race Started! Lap {_currentLap}");
                return;
            }

            // Normal progression
            if (index == _lastCheckpointIndex + 1)
            {
                _lastCheckpointIndex = index;
                OnCheckpointPassed?.Invoke(index);
            }
            // Finish Line (index 0) after hitting last checkpoint
            else if (index == 0 && _lastCheckpointIndex == _totalCheckpoints - 1)
            {
                OnLapCompleted?.Invoke(_currentLap);
                _currentLap++;
                _lastCheckpointIndex = 0;
                Debug.Log($"Lap Finished! Starting Lap {_currentLap}");
            }
        }
    }
}`,

  'RaceManager.cs': `using System.Collections;
using System.Linq;
using UnityEngine;
using UnityEngine.SceneManagement;
using DriftyRoads.Core;
using DriftyRoads.Player;

namespace DriftyRoads.Race
{
    public class RaceManager : MonoBehaviour
    {
        public static RaceManager Instance { get; private set; }

        [Header("Race Settings")]
        [SerializeField] private int totalLaps = 3;
        [SerializeField] private int countdownSeconds = 3;
        
        [Header("References")]
        [SerializeField] private CarController playerCar;
        [SerializeField] private Checkpoint[] allCheckpoints; // Drag in order via Inspector

        // Public Events
        public event System.Action<int> OnCountdownUpdate; // Sends 3, 2, 1, 0(Go)
        public event System.Action OnRaceStart;
        public event System.Action OnRaceFinish;
        public event System.Action<float> OnLapTimeUpdated; // For UI per frame

        public GameState CurrentState { get; private set; }
        public int TotalLaps => totalLaps;
        public float CurrentRaceTime { get; private set; }
        public float CurrentLapTime { get; private set; }
        public float BestLapTime { get; private set; } = float.MaxValue;

        private LapTracker _playerTracker;

        private void Awake()
        {
            if (Instance != null) Destroy(gameObject);
            Instance = this;
            
            CurrentState = GameState.NotStarted;
        }

        private void Start()
        {
            // Auto-find checkpoints if not assigned, sorted by index
            if (allCheckpoints == null || allCheckpoints.Length == 0)
            {
                allCheckpoints = FindObjectsOfType<Checkpoint>().OrderBy(c => c.index).ToArray();
            }

            // Setup Player
            if (playerCar != null)
            {
                playerCar.SetControlState(false); // Disable input
                
                _playerTracker = playerCar.gameObject.AddComponent<LapTracker>();
                _playerTracker.Initialize(this, allCheckpoints.Length); // Length includes start/finish
                _playerTracker.OnLapCompleted += HandleLapCompleted;
            }

            StartCoroutine(StartRaceRoutine());
        }

        private void Update()
        {
            if (CurrentState == GameState.Racing)
            {
                CurrentRaceTime += Time.deltaTime;
                CurrentLapTime += Time.deltaTime;
                OnLapTimeUpdated?.Invoke(CurrentLapTime);
            }
        }

        private IEnumerator StartRaceRoutine()
        {
            CurrentState = GameState.Countdown;
            
            int count = countdownSeconds;
            while (count > 0)
            {
                OnCountdownUpdate?.Invoke(count);
                yield return new WaitForSeconds(1f);
                count--;
            }

            OnCountdownUpdate?.Invoke(0); // "GO!"
            StartRace();
        }

        private void StartRace()
        {
            CurrentState = GameState.Racing;
            if (playerCar != null) playerCar.SetControlState(true);
            OnRaceStart?.Invoke();
        }

        private void HandleLapCompleted(int finishedLapNum)
        {
            if (CurrentLapTime < BestLapTime)
            {
                BestLapTime = CurrentLapTime;
            }
            
            CurrentLapTime = 0f;

            if (finishedLapNum >= totalLaps)
            {
                FinishRace();
            }
        }

        private void FinishRace()
        {
            CurrentState = GameState.Finished;
            if (playerCar != null) playerCar.SetControlState(false);
            OnRaceFinish?.Invoke();
            Debug.Log("Race Finished!");
        }

        public void RestartRace()
        {
            SceneManager.LoadScene(SceneManager.GetActiveScene().name);
        }

        public void QuitToMenu()
        {
            SceneManager.LoadScene(Constants.SCENE_MAIN_MENU);
        }
    }
}`,

  // --- UI ---
  'MainMenuUI.cs': `using UnityEngine;
using UnityEngine.SceneManagement;
using DriftyRoads.Core;

namespace DriftyRoads.UI
{
    public class MainMenuUI : MonoBehaviour
    {
        public void OnPlayClicked()
        {
            SceneManager.LoadScene(Constants.SCENE_RACE_01);
        }

        public void OnQuitClicked()
        {
            Debug.Log("Quitting Game...");
            Application.Quit();
        }
    }
}`,

  'RaceHUD.cs': `using UnityEngine;
using TMPro; // Assuming TextMeshPro is used (recommended), otherwise use UnityEngine.UI.Text
using DriftyRoads.Race;
using DriftyRoads.Player;

namespace DriftyRoads.UI
{
    public class RaceHUD : MonoBehaviour
    {
        [Header("UI References")]
        [SerializeField] private TextMeshProUGUI timerText;
        [SerializeField] private TextMeshProUGUI lapText;
        [SerializeField] private TextMeshProUGUI speedText;
        [SerializeField] private TextMeshProUGUI centerMessageText; // For Countdown/Finish
        [SerializeField] private GameObject finishPanel;

        [Header("Data References")]
        [SerializeField] private CarController playerCar;

        private LapTracker _playerTracker;

        private void Start()
        {
            if (RaceManager.Instance != null)
            {
                RaceManager.Instance.OnCountdownUpdate += UpdateCountdown;
                RaceManager.Instance.OnRaceFinish += ShowFinishScreen;
            }

            if (playerCar != null)
            {
                _playerTracker = playerCar.GetComponent<LapTracker>();
                if (_playerTracker != null)
                {
                    _playerTracker.OnLapCompleted += UpdateLapDisplay;
                }
            }
            
            UpdateLapDisplay(0);
            if (finishPanel != null) finishPanel.SetActive(false);
        }

        private void Update()
        {
            if (RaceManager.Instance == null) return;

            // Update Timer
            float time = RaceManager.Instance.CurrentRaceTime;
            // Format 00:00.00
            System.TimeSpan t = System.TimeSpan.FromSeconds(time);
            if(timerText) timerText.text = string.Format("{0:D2}:{1:D2}.{2:D2}", t.Minutes, t.Seconds, t.Milliseconds / 10);

            // Update Speed
            if (playerCar != null && speedText != null)
            {
                speedText.text = $"{Mathf.Round(playerCar.GetSpeedKmh())} KM/H";
            }
        }

        private void UpdateCountdown(int count)
        {
            if (centerMessageText == null) return;
            
            centerMessageText.gameObject.SetActive(true);
            if (count > 0)
                centerMessageText.text = count.ToString();
            else
                centerMessageText.text = "GO!";
            
            if (count == 0) Invoke(nameof(HideCenterMessage), 1f);
        }

        private void HideCenterMessage()
        {
            if (centerMessageText) centerMessageText.gameObject.SetActive(false);
        }

        private void UpdateLapDisplay(int completedLaps)
        {
            if (lapText == null || RaceManager.Instance == null) return;
            
            // Current lap is completed + 1, unless finished
            int current = Mathf.Min(completedLaps + 1, RaceManager.Instance.TotalLaps);
            lapText.text = $"LAP {current} / {RaceManager.Instance.TotalLaps}";
        }

        private void ShowFinishScreen()
        {
            if (finishPanel != null) finishPanel.SetActive(true);
            if (centerMessageText) 
            {
                centerMessageText.gameObject.SetActive(true);
                centerMessageText.text = "FINISHED!";
            }
        }
    }
}`,

  'PauseMenu.cs': `using UnityEngine;
using DriftyRoads.Race;

namespace DriftyRoads.UI
{
    public class PauseMenu : MonoBehaviour
    {
        [SerializeField] private GameObject pausePanel;

        private bool _isPaused = false;

        private void Start()
        {
            if(pausePanel) pausePanel.SetActive(false);
        }

        private void Update()
        {
            if (Input.GetKeyDown(KeyCode.Escape))
            {
                TogglePause();
            }
        }

        public void TogglePause()
        {
            _isPaused = !_isPaused;
            if(pausePanel) pausePanel.SetActive(_isPaused);
            
            // Simple time scaling pause
            Time.timeScale = _isPaused ? 0f : 1f;
        }

        public void Resume()
        {
            _isPaused = false;
            if(pausePanel) pausePanel.SetActive(false);
            Time.timeScale = 1f;
        }

        public void QuitToMain()
        {
            Time.timeScale = 1f; // Ensure time is back to normal before leaving
            if (RaceManager.Instance != null)
            {
                RaceManager.Instance.QuitToMenu();
            }
            else
            {
                UnityEngine.SceneManagement.SceneManager.LoadScene("MainMenu");
            }
        }
    }
}`
};

// --- TREE NODE COMPONENT ---

const TreeNode = ({ node, level = 0, onSelect, selectedFile }) => {
  const [isOpen, setIsOpen] = useState(true);

  if (node.type === 'file') {
    return (
      <div 
        className={`flex items-center py-1 px-2 cursor-pointer hover:bg-gray-700 ${selectedFile === node.id ? 'bg-blue-600 text-white' : 'text-gray-300'}`}
        style={{ paddingLeft: `${level * 16 + 8}px` }}
        onClick={() => onSelect(node.id)}
      >
        {node.name.endsWith('.cs') ? <FileCode size={16} className="mr-2 text-green-400" /> : <FileText size={16} className="mr-2 text-gray-400" />}
        <span className="text-sm font-mono">{node.name}</span>
      </div>
    );
  }

  return (
    <div>
      <div 
        className="flex items-center py-1 px-2 cursor-pointer hover:bg-gray-700 text-gray-200"
        style={{ paddingLeft: `${level * 16 + 8}px` }}
        onClick={() => setIsOpen(!isOpen)}
      >
        {isOpen ? <ChevronDown size={16} className="mr-2" /> : <ChevronRight size={16} className="mr-2" />}
        <Folder size={16} className="mr-2 text-yellow-500" />
        <span className="text-sm font-bold">{node.name}</span>
      </div>
      {isOpen && (
        <div>
          {node.children.map((child, idx) => (
            <TreeNode key={idx} node={child} level={level + 1} onSelect={onSelect} selectedFile={selectedFile} />
          ))}
        </div>
      )}
    </div>
  );
};

// --- MAIN APP ---

export default function App() {
  const [selectedFile, setSelectedFile] = useState('README.md');
  const [copied, setCopied] = useState(false);
  const [isSidebarOpen, setSidebarOpen] = useState(true);

  const copyToClipboard = () => {
    if (FILE_CONTENT[selectedFile]) {
      navigator.clipboard.writeText(FILE_CONTENT[selectedFile]);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    }
  };

  const projectStructure = {
    name: 'drifty-roads',
    type: 'folder',
    children: [
      {
        name: 'Assets',
        type: 'folder',
        children: [
          {
            name: 'DriftyRoads',
            type: 'folder',
            children: [
              {
                name: 'Scripts',
                type: 'folder',
                children: [
                  {
                    name: 'Core',
                    type: 'folder',
                    children: [
                      { name: 'Constants.cs', type: 'file', id: 'Constants.cs' },
                      { name: 'GameState.cs', type: 'file', id: 'GameState.cs' },
                    ]
                  },
                  {
                    name: 'Player',
                    type: 'folder',
                    children: [
                      { name: 'CarController.cs', type: 'file', id: 'CarController.cs' },
                      { name: 'CameraFollow.cs', type: 'file', id: 'CameraFollow.cs' },
                    ]
                  },
                  {
                    name: 'AI',
                    type: 'folder',
                    children: [
                      { name: 'AICarController.cs', type: 'file', id: 'AICarController.cs' },
                      { name: 'WaypointCircuit.cs', type: 'file', id: 'WaypointCircuit.cs' },
                    ]
                  },
                  {
                    name: 'Race',
                    type: 'folder',
                    children: [
                      { name: 'RaceManager.cs', type: 'file', id: 'RaceManager.cs' },
                      { name: 'LapTracker.cs', type: 'file', id: 'LapTracker.cs' },
                      { name: 'Checkpoint.cs', type: 'file', id: 'Checkpoint.cs' },
                    ]
                  },
                  {
                    name: 'UI',
                    type: 'folder',
                    children: [
                      { name: 'MainMenuUI.cs', type: 'file', id: 'MainMenuUI.cs' },
                      { name: 'RaceHUD.cs', type: 'file', id: 'RaceHUD.cs' },
                      { name: 'PauseMenu.cs', type: 'file', id: 'PauseMenu.cs' },
                    ]
                  }
                ]
              },
              { name: 'Scenes', type: 'folder', children: [] },
              { name: 'Prefabs', type: 'folder', children: [] },
              { name: 'Materials', type: 'folder', children: [] },
            ]
          },
          {
            name: 'PolygonStreetRacer',
            type: 'folder',
            children: []
          }
        ]
      },
      { name: '.gitignore', type: 'file', id: '.gitignore' },
      { name: 'README.md', type: 'file', id: 'README.md' },
    ]
  };

  return (
    <div className="flex h-screen bg-gray-900 text-gray-100 font-sans overflow-hidden">
      {/* Sidebar - Desktop */}
      <div className={`hidden md:flex flex-col w-80 bg-gray-800 border-r border-gray-700 h-full`}>
        <div className="p-4 border-b border-gray-700">
          <h1 className="text-xl font-bold text-blue-400">Drifty Roads</h1>
          <p className="text-xs text-gray-400 mt-1">Unity Project Generator</p>
        </div>
        <div className="flex-1 overflow-y-auto p-2">
          <TreeNode node={projectStructure} onSelect={setSelectedFile} selectedFile={selectedFile} />
        </div>
      </div>

      {/* Sidebar - Mobile Toggle */}
      <div className={`fixed inset-0 z-40 bg-black/50 md:hidden ${isSidebarOpen ? 'block' : 'hidden'}`} onClick={() => setSidebarOpen(false)}></div>
      <div className={`fixed inset-y-0 left-0 z-50 w-72 bg-gray-800 transition-transform md:hidden ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full'}`}>
        <div className="p-4 flex justify-between items-center border-b border-gray-700">
          <h1 className="text-xl font-bold text-blue-400">Project Files</h1>
          <button onClick={() => setSidebarOpen(false)}><X /></button>
        </div>
        <div className="overflow-y-auto h-full p-2">
          <TreeNode node={projectStructure} onSelect={(id) => { setSelectedFile(id); setSidebarOpen(false); }} selectedFile={selectedFile} />
        </div>
      </div>

      {/* Main Content */}
      <div className="flex-1 flex flex-col h-full overflow-hidden">
        {/* Header */}
        <div className="h-14 bg-gray-800 border-b border-gray-700 flex items-center justify-between px-4">
          <div className="flex items-center">
            <button className="md:hidden mr-3" onClick={() => setSidebarOpen(true)}><Menu /></button>
            <div className="flex items-center space-x-2">
               {selectedFile.endsWith('.cs') ? <FileCode className="text-green-400" size={20} /> : <FileText className="text-gray-400" size={20} />}
               <span className="font-mono font-medium">{selectedFile}</span>
            </div>
          </div>
          <button 
            onClick={copyToClipboard}
            className={`flex items-center space-x-2 px-3 py-1.5 rounded text-sm transition-colors ${copied ? 'bg-green-600 text-white' : 'bg-blue-600 hover:bg-blue-500 text-white'}`}
          >
            {copied ? <Check size={16} /> : <Copy size={16} />}
            <span>{copied ? 'Copied!' : 'Copy Code'}</span>
          </button>
        </div>

        {/* Code Editor View */}
        <div className="flex-1 overflow-auto bg-gray-900 p-4 relative">
          <pre className="text-sm font-mono text-gray-300 leading-relaxed p-4 bg-gray-950 rounded-lg shadow-inner min-h-full whitespace-pre-wrap break-all md:break-normal">
            {FILE_CONTENT[selectedFile] || "// Select a file to view content"}
          </pre>
        </div>
        
        {/* Footer */}
        <div className="bg-gray-800 border-t border-gray-700 p-2 text-center text-xs text-gray-500">
          Generated for Unity 2022 LTS • WebGL Target • GitHub Pages Ready
        </div>
      </div>
    </div>
  );
}
